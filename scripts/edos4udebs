#!/usr/bin/perl
# Â© 2013 Cyril Brulebois <kibi@debian.org>

use strict;
use warnings;

use Email::MIME;
use Email::Sender::Simple qw(sendmail);
use File::Path qw(make_path);
use File::Slurp;
use Getopt::Long;
use List::MoreUtils qw(uniq);
use Storable;

# Option handling:
my $sync = 1;
my $store = 1;
my $mail;
my $index_output = 'index.html';
my $diff_output = 'diff.txt';
my $workdir = 'edos.tmp';
GetOptions(
  "sync!"   => \$sync,
  "store!"  => \$store,
  "mail=s"  => \$mail,
  "index=s" => \$index_output,
  "diff=s"  => \$diff_output,
  "workdir=s" => \$workdir,
) or die "Usage: $0 --[no]sync --[no]store --mail=notification\@somewhere --index=$index_output --diff=$diff_output --workdir=$workdir";

# Configuration goes here:
my %known = qw(
  udev-udeb            722951
  libgtk-3-0-udeb      723163
  libsdl1.2debian-udeb 723165
  cdebootstrap-udeb    723167
  libmount1-udeb       723168
  libvte-2.90-9-udeb   723169
);

my $mirror = "/srv/ftp.debian.org/ftp";

my @suites = qw(stable testing unstable);

# Work starts here:
my @allarchs;
my %availables;
my %new;
for my $suite (@suites) {
  my $suitedir = "$workdir/$suite";
  my %failed;
  make_path($suitedir, { error => my $err });
  if ($err && @$err) {
    die "Unable to create workdir: $suitedir: @$err";
  }
  for my $arch_dir (glob "$mirror/dists/$suite/main/debian-installer/binary-*") {
    (my $arch = $arch_dir) =~ s{.*/binary-}{};
    # binary-all isn't interesting:
    next if $arch eq 'all';

    # uniq-ified once later:
    push @allarchs, $arch;
    $availables{$suite}{$arch} = 1;

    # FIXME: IO::Compress::Gzip would be nicer to use
    my $packages_file = "$suitedir/$arch-Packages";

    # For debugging purposes, this sync can be disabled (--nosync):
    if ($sync) {
      system("zcat $arch_dir/Packages.gz > $packages_file")==0
        or die "Unable to zcat $arch_dir/Packages.gz";

      # Add a few special packages in there:
      open my $fh, '>>', $packages_file
        or die "Unable to append to $packages_file";
      for my $fake (qw(libgcc1 libnewt0.52)) {
        print $fh "Package: $fake\nArchitecture: $arch\nVersion: fake\n\n";
      }
      close $fh
        or die "Unable to close $packages_file";
    }

    # Call edos, explaining issues.
    my $current;
    my $alt;
    my $graph = "digraph {\n";
    $graph .= "node[shape=box];\n";
    my @deps;
    my @involved;
    for my $line (`edos-debcheck -quiet -failures -explain < $packages_file`) {
      if ($line =~ /^(\S+)\s.*: FAILED$/) {
        my $package = $1;
        push @{$failed{$package}}, $arch;
      }
      # FIXME: Sadly, "one of" can have a single child, so treat both case the same way for now:
      #elsif ($line =~ /^  (\S+)\s.* depends on one of:$/) {
      #  my $package = $1;
      #  $current = "$package-|";
      #  $graph .= "\"$package\" -> \"$package-|\"\n";
      #}
      elsif ($line =~ /^  (\S+)\s.* depends on (missing|one of):$/) {
        my $package = $1;
        $current = $package;
        push @involved, $current;
      }
      elsif ($line =~ /^  - (\S+)\s.*$/) {
        my $package = $1;
        push @deps, "\"$current\" -> \"$package\"";
        push @involved, $package;
      }
      else {
        die "Unable to parse line: $line";
      }
    }
    $graph .= join "\n", uniq sort @deps;

    # Special style for known, buggy packages:
    for my $package (uniq sort @involved) {
      if (grep { $package eq $_ } keys %known) {
        my $bug = "#". $known{$package};
        $graph .= "  \"$package\"[color=\"red\",style=\"dashed,bold\",label=\"$package\\n$bug\"];\n";
      }
    }

    $graph .= "}\n";
    write_file("$workdir/graph-$suite-$arch.dot", $graph);
  }

  for my $package (sort keys %failed) {
    $new{ "$suite/$package" } = join ' ', @{$failed{$package}};
  }
}

# Little helpers for the HTML output:
sub link2graph {
  my $suite = shift;
  my $arch = shift;
  return ""
    if ! $availables{$suite}{$arch};
  return "<a href=\"graph-$suite-$arch.png\">$arch</a>";
}

sub link2bug {
  my $p = shift;
  my $b = $known{ $p };
  if ($b) {
    return "$p (<a href=\"http://bugs.debian.org/$b\">#$b</a>)";
  }
  else {
    return "$p";
  }
}

### HTML summary, current state
@allarchs = uniq sort @allarchs;
my $colspan = 1+scalar(@allarchs);
my $html = "<html><head><title>udeb uninstallability status</title></head>\n";
$html .= "<body><p>Jump to suite:" . (join '', map { " <a href=\"#$_\">$_</a>" } @suites) . "</p>";
$html .= "<table border=\"1\" cellpadding=3 style=\"border-collapse: collapse; margin: auto; \">\n";

my $total;
for my $suite (@suites) {
  $html .= "<tr><td colspan=\"$colspan\"><h1 style=\"margin-top: 20px; text-align: center;\"><a name=\"$suite\">Uninstallable packages in $suite</a></h1></td></tr>\n";
  $html .= "<tr><td></td>" . (join '', map { "<td>" . link2graph($suite, $_) ."</td>" } @allarchs) . "</tr>\n";
  for my $k (sort keys %new) {
    next if $k !~ m{^$suite/};
    (my $package = $k ) =~ s{.*/}{};
    $html .= "<tr><td>" . link2bug($package) . "</td>";
    my @broken = split / /, $new{$k};
    for my $arch (@allarchs) {
      if (grep { $arch eq $_ } @broken) {
        $html .= "<td>$arch</td>";
        $total += 1;
      }
      else {
        $html .= "<td></td>";
      }
    }
    $html .= "</tr>\n";
  }
}
$html .= "</table></body></html>\n";
write_file("$workdir/$index_output", $html);


### Text summary, diff against previous state
my $memory = "$workdir/edos.storable";
my %old = (-f $memory) ? %{ retrieve($memory) } : ();

if (%old) {
  # NOTE: We could easily distinguish new broken packages, along with
  # entirely fixed packages, but there are always a bunch of
  # arch-specific udebs/dependencies, etc. which will make that less
  # useful than it could be. So stick to per-arch granularity for a
  # given suite/package.
  my $diff;
  my %changed;
  for my $k (uniq sort (keys %old, keys %new)) {
    my @o = split / /, ($old{$k}||'');
    my @n = split / /, ($new{$k}||'');
    my @ko;
    my @ok;
    for my $arch (uniq sort (@o, @n)) {
      if (not grep { $arch eq $_ } @o) {
        push @ko, $arch;
      }
      elsif (not grep { $arch eq $_ } @n) {
        push @ok, $arch;
      }
    }
    (my $suite = $k) =~ s{/.*}{};
    (my $package = $k) =~ s{.*/}{};
    $changed{$suite}{ko}{$package} = join ' ', @ko if @ko;
    $changed{$suite}{ok}{$package} = join ' ', @ok if @ok;
  }

  my %states = (
    "ok" => "Newly-fixed packages",
    "ko" => "Newly-broken packages",
  );
  my %stats = (
    "ok" => 0,
    "ko" => 0,
  );

  # Walk suites, check which changed, in which direction:
  for my $suite (@suites) {
    next
      if not $changed{$suite};
    for my $state (keys %states) {
      next
        if not $changed{$suite}{$state};

      $diff .= "$states{$state} in $suite\n";
      for my $package (sort keys $changed{$suite}{$state}) {
        $diff .= sprintf "  %-40s %s\n", $package, $changed{$suite}{$state}{$package};
        $stats{$state}+=split ' ', $changed{$suite}{$state}{$package};
      }
      $diff .= "\n";
    }
  }

  # Karma computing:
  my $trend = (($stats{ko} == $stats{ok})?"equilibrium":(($stats{ko} < $stats{ok})?"better":"worse")) . " (+$stats{ko}/-$stats{ok})";
  $diff .= "Uninstallability trend: $trend\n";
  $diff .= "Uninstallability count: $total\n";
  write_file("$workdir/$diff_output", $diff);

  # Optional mail:
  if ($stats{ok} + $stats{ko} > 0) {
    if ($mail) {
      my $subject = "udeb uninstallability trend: $trend";
      my $message = Email::MIME->create(
        header_str => [
          From    => 'udeb uninstallability watcher <debian-boot@lists.debian.org>',
          To      => $mail,
          Subject => $subject,
        ],
        attributes => {
          encoding => "quoted-printable",
          charset  => "UTF-8",
        },
        body_str => $diff,
      );
      sendmail($message);
    }
  }
} else {
  # Touch the file for the caller to be happy:
  write_file("$workdir/$diff_output", 'No previous state');
}

# This can be disabled (--nostore):
if ($store) {
  store \%new, $memory
    or die "Unable to store current status to $memory";
}
